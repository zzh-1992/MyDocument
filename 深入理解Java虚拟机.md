# 第2章 Java内存区域与内存溢出异常

## 2.1概述

## 2.2运行时数据区域

### 2.2.1 程序计数器

**程序计数器**是一块较小的内存空间，它可以看作是当前线程所执行字节码的**行号指示器**。

### 2.2.2 Java虚拟机栈

**Java虚拟机栈**是**线程私有**的。java虚拟机栈描述的是**Java方法执行的线程内存模型**：每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表，操作数栈，动态连接，方法出口等信息。

### 2.2.3 本地方法栈

Hot-spot虚拟机直接把本地方法栈和虚拟机栈合二为一。本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMnenmoryError异常。

###  2.2.4 Java堆

Java堆是被所有线程共享等一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB),以提升对象分配时的效率。Java堆可以通过参数-Xmx和-Xms设定。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMenoryError异常。

### 2.2.5 方法区

方法区和java堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 2.2.6 运行时常量池

### 2.2.7 直接内存

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

### 2.3.2 对象的内存布局

在HotSpot虚拟机里，对象在对内存中的存储布局可以划分为三个部分：*对象头*（Header）、*实例数据*（Instance Data）和*对齐填充*（Padding）。

​	HotSpot虚拟机对象的对象头部分包含两类信息。第一类用于存储对象自身的运行时数据，如**哈希码**（HashCode）、**GC分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程ID**、**偏向时间戳**等，官方称为“***Mark Word***”。Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存存储尽量多的数据。例如在32位的HotSpot虚拟机中，如对象为被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象的哈希码，4个比特用于存储对象的分代年龄，2个比特用与存储锁标识位，1个比特固定为0。

​	对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

实例数据：是对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容。

对象的第三部分是对齐填充，它仅仅起占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

 > 第三章 垃圾收集器与内存分配策略

## 3.1 概述

## 3.2 对象存活

### 3.2.1 引用计数法

### 3.2.2 可达性分析算法

### 3.2.3 再谈引用

Java引用

强引用

软引用

弱引用

虚引用

### 3.2.4 生存还是死亡？

### 3.2.5 回收方法区

## 3.3 垃圾收集算法

垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）。这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。

### 3.3.1 分代收集理论

设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

### 3.3.2 标记-清楚算法

首先标记出所有需要回收的对象，在标记完后，统一回收掉所有被标记过的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）。

缺点：效率不稳定和空间碎片化

### 3.3.3 标记-复制算法

一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用的内存区域按容量大小划分为大小相等的两块，每次只使用一种的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

代价：将可用内存缩小为两原来的一半。

3.3.4 标记-整理算法 

#第7章 虚拟机类加载机制
## 7.1 概述
Java虚拟机把描述类de数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用到Java类型，这个
过程被乘称作虚拟机到类加载机制。

## 7.2 类加载到时机
一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它到整个生命周期将会经历加载，验证，准备，解析，初始化，使用，卸载七个阶段。其中验证、
准备、解析三个部分统称为连接。

## 7.3 类加载到过程
## 7.4 类加载器
Java虚拟机设计团队有意把类加载阶段中到"通过一个类到全限定名来获取描述该类的二进制流"这个动作放到java虚拟机外部去实现，以便让
应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为"类加载器"(Class Loader)

## 7.4.1 类于类加载器

## 7.4.2 双亲委派模型
站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，
是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类
java.lang.ClassLoader.

绝大多数java程序都会使用到以下3个系统提供到类加载来进行加载。
- 启动类加载器 Bootstrap Class Loader

这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数说指定de路径中存放到，而且是java虚拟机能够识别的(按照
  文件名识别，如rt.jar、tools.jar,名字不符合和的类库即使放在lib目录中也不会被加载)类库加载到虚拟机到内存中。启动类加载器无法被java程序直接
  引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null即可。

- 扩展类加载器 Extension Class Loader

这个类加载器是在类sum.misc.Launcher$ExtClassLoader中以java代码的形式实现。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统
  变量所指定的路径中所有的类库。

- 应用程序类加载器 Application Class Loader

这个类加载器是由sum.misc.Launch$AppClassLoader来实现。由于应用程序类加载器是是ClassLoader类中的getSystemClassLoader()方法的返回值，
  所以有些场合中也称它为"系统类加载器"。它负责加载用户类路径(ClassPath)上所有的类库。

双亲委派模型要求初了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

双亲委派模型的工作过程：如果一个类加载器收到类类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的
类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动器类加载器中，只有当父加载器返回自己无法完成这个加载请求（它的搜索范围中没有
找到所需要的类）时，子加载器才会尝试自己去完成加载。



# 第12章 java内存模型与线程

# 第13章 线程安全与锁优化

## 13.1概述

## 13.2线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么称为这个对象是线程安全的。

### 13.2.1java语言中的线程安全

1.不可变

2.绝对线程安全

3.相对线程安全

4.线程兼容

5.线程对立

### 13.2.2 线程安全的实现方法

1.互斥同步

2.非阻塞同步

3.无同步方案

## 13.3 锁优化

- 适应性自旋

- 锁消除

- 锁膨胀

- 轻量级锁

- 偏向锁

### 13.3.1 自旋锁于自适应自旋

为了让线程等待，只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。

自旋锁在JDK1.4.2中就已经引入，默认关闭，可以使用-XX:+UseSpinging参数开启，在JDK1.6中已经改为默认开启。自旋次数的默认值是十次，用户也可以使用参数:-XX:PreBlockSpin来自行更改。在JDK1.6中对自旋锁的优化，引入了自适应自旋。，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

### 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争对锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。

### 13.3.3 锁粗化

如果虚拟机探测到有这样一串零碎的操作需要对同一个对象加锁，将会把加锁同步的范围扩展(粗化)到整个操作序列的外部。

### 13.3.4 轻量级锁

### 13.3.5 偏向锁













