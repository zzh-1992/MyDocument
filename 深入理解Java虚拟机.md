# 第二章 Java内存区域与内存溢出异常

## 2.1概述

## 2.2运行时数据区域

### 2.2.1 程序计数器

**程序计数器**是一块较小的内存空间，它可以看作是当前线程所执行字节码的**行号指示器**。

### 2.2.2 Java虚拟机栈

**Java虚拟机栈**是**线程私有**的。java虚拟机栈描述的是**Java方法执行的线程内存模型**：每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表，操作数栈，动态连接，方法出口等信息。

### 2.2.3 本地方法栈

Hot-spot虚拟机直接把本地方法栈和虚拟机栈合二为一。本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMnenmoryError异常。

###  2.2.4 Java堆

Java堆是被所有线程共享等一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB),以提升对象分配时的效率。Java堆可以通过参数-Xmx和-Xms设定。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMenoryError异常。

### 2.2.5 方法区

方法区和java堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 2.2.6 运行时常量池

### 2.2.7 直接内存

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

### 2.3.2 对象的内存布局

在HotSpot虚拟机里，对象在对内存中的存储布局可以划分为三个部分：*对象头*（Header）、*实例数据*（Instance Data）和*对齐填充*（Padding）。

​	HotSpot虚拟机对象的对象头部分包含两类信息。第一类用于存储对象自身的运行时数据，如**哈希码**（HashCode）、**GC分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程ID**、**偏向时间戳**等，官方称为“***Mark Word***”。Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存存储尽量多的数据。例如在32位的HotSpot虚拟机中，如对象为被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象的哈希码，4个比特用于存储对象的分代年龄，2个比特用与存储锁标识位，1个比特固定为0。

​	对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

实例数据：是对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容。

对象的第三部分是对齐填充，它仅仅起占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

# 第三章 垃圾收集器与内存分配策略

## 3.1 概述

## 3.2 对象存活

### 3.2.1 引用计数法

### 3.2.2 可达性分析算法

### 3.2.3 再谈引用

Java引用

强引用

软引用

弱引用

虚引用

### 3.2.4 生存还是死亡？

### 3.2.5 回收方法区

## 3.3 垃圾收集算法

垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）。这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。

### 3.3.1 分代收集理论

设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

### 3.3.2 标记-清楚算法

首先标记出所有需要回收的对象，在标记完后，统一回收掉所有被标记过的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）。

缺点：效率不稳定和空间碎片化

### 3.3.3 标记-复制算法

一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用的内存区域按容量大小划分为大小相等的两块，每次只使用一种的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

代价：将可用内存缩小为两原来的一半。

3.3.4 标记-整理算法 









