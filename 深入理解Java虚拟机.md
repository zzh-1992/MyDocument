# 第二章 Java内存区域与内存溢出异常

## 2.1概述

## 2.2运行时数据区域

### 2.2.1 程序计数器

**程序计数器**是一块较小的内存空间，它可以看作是当前线程所执行字节码的**行号指示器**。

### 2.2.2 Java虚拟机栈

**Java虚拟机栈**是**线程私有**的。java虚拟机栈描述的是**Java方法执行的线程内存模型**：每个方法被执行的时候，java虚拟机都会同步创建一个栈桢用于存储局部变量表，操作数栈，动态连接，方法出口等信息。

### 2.2.3 本地方法栈

Hot-spot虚拟机直接把本地方法栈和虚拟机栈合二为一。本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMnenmoryError异常。

###  2.2.4 Java堆

Java堆是被所有线程共享等一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。

如果从分配内存的角度看，所有线程共享的Java堆中可以划分多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB),以提升对象分配时的效率。Java堆可以通过参数-Xmx和-Xms设定。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMenoryError异常。

### 2.2.5 方法区

方法区和java堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

### 2.2.6 运行时常量池

### 2.2.7 直接内存

## 2.3 HotSpot虚拟机对象探秘

### 2.3.1 对象的创建

### 2.3.2 对象的内存布局

在HotSpot虚拟机里，对象在对内存中的存储布局可以划分为三个部分：*对象头*（Header）、*实例数据*（Instance Data）和*对齐填充*（Padding）。

​	HotSpot虚拟机对象的对象头部分包含两类信息。第一类用于存储对象自身的运行时数据，如**哈希码**（HashCode）、**GC分代年龄**、**锁状态标志**、**线程持有的锁**、**偏向线程ID**、**偏向时间戳**等，官方称为“***Mark Word***”。Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存存储尽量多的数据。例如在32位的HotSpot虚拟机中，如对象为被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象的哈希码，4个比特用于存储对象的分代年龄，2个比特用与存储锁标识位，1个比特固定为0。

​	对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

实例数据：是对象真正存储的有效信息，即我们在程序代码里所定义的各种类型的字段内容。

对象的第三部分是对齐填充，它仅仅起占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

 > 第三章 垃圾收集器与内存分配策略

## 3.1 概述

## 3.2 对象存活

### 3.2.1 引用计数法

### 3.2.2 可达性分析算法

### 3.2.3 再谈引用

Java引用

强引用

软引用

弱引用

虚引用

### 3.2.4 生存还是死亡？

### 3.2.5 回收方法区

## 3.3 垃圾收集算法

垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）。这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。

### 3.3.1 分代收集理论

设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。

### 3.3.2 标记-清楚算法

首先标记出所有需要回收的对象，在标记完后，统一回收掉所有被标记过的对象（也可以反过来，标记存活的对象，统一回收所有未被标记的对象）。

缺点：效率不稳定和空间碎片化

### 3.3.3 标记-复制算法

一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用的内存区域按容量大小划分为大小相等的两块，每次只使用一种的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉。

代价：将可用内存缩小为两原来的一半。

3.3.4 标记-整理算法 

#第7章 虚拟机类加载机制
## 7.1 概述
Java虚拟机把描述类de数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用到Java类型，这个
过程被乘称作虚拟机到类加载机制。

## 7.2 类加载到时机
一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它到整个生命周期将会经历加载，验证，准备，解析，初始化，使用，卸载七个阶段。其中验证、
准备、解析三个部分统称为连接。

## 7.3 类加载到过程
## 7.4 类加载器
Java虚拟机设计团队有意把类加载阶段中到"通过一个类到全限定名来获取描述该类的二进制流"这个动作放到java虚拟机外部去实现，以便让
应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为"类加载器"(Class Loader)

## 7.4.1 类于类加载器

## 7.4.2 双亲委派模型
站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，
是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类
java.lang.ClassLoader.

绝大多数java程序都会使用到以下3个系统提供到类加载来进行加载。
- 启动类加载器 Bootstrap Class Loader

这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数说指定de路径中存放到，而且是java虚拟机能够识别的(按照
  文件名识别，如rt.jar、tools.jar,名字不符合和的类库即使放在lib目录中也不会被加载)类库加载到虚拟机到内存中。启动类加载器无法被java程序直接
  引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null即可。
  
- 扩展类加载器 Extension Class Loader

这个类加载器是在类sum.misc.Launcher$ExtClassLoader中以java代码的形式实现。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统
  变量所指定的路径中所有的类库。
  
- 应用程序类加载器 Application Class Loader

这个类加载器是由sum.misc.Launch$AppClassLoader来实现。由于应用程序类加载器是是ClassLoader类中的getSystemClassLoader()方法的返回值，
  所以有些场合中也称它为"系统类加载器"。它负责加载用户类路径(ClassPath)上所有的类库。
  
双亲委派模型要求初了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

双亲委派模型的工作过程：如果一个类加载器收到类类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每一个层次的
类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动器类加载器中，只有当父加载器返回自己无法完成这个加载请求（它的搜索范围中没有
找到所需要的类）时，子加载器才会尝试自己去完成加载。











